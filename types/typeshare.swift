/*
 Generated by typeshare 1.0.0
 */

import Foundation

public struct User: Codable {
	public let id: UInt32
	public let name: String
	public let discriminator: String

	public init(id: UInt32, name: String, discriminator: String) {
		self.id = id
		self.name = name
		self.discriminator = discriminator
	}
}

public enum UserResponse: Codable {
	case ok(User)
	case err(String)

	enum CodingKeys: String, CodingKey, Codable {
		case ok = "Ok",
			err = "Err"
	}

	private enum ContainerCodingKeys: String, CodingKey {
		case type, value
	}

	public init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: ContainerCodingKeys.self)
		if let type = try? container.decode(CodingKeys.self, forKey: .type) {
			switch type {
			case .ok:
				if let content = try? container.decode(User.self, forKey: .value) {
					self = .ok(content)
					return
				}
			case .err:
				if let content = try? container.decode(String.self, forKey: .value) {
					self = .err(content)
					return
				}
			}
		}
		throw DecodingError.typeMismatch(UserResponse.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for UserResponse"))
	}

	public func encode(to encoder: Encoder) throws {
		var container = encoder.container(keyedBy: ContainerCodingKeys.self)
		switch self {
		case .ok(let content):
			try container.encode(CodingKeys.ok, forKey: .type)
			try container.encode(content, forKey: .value)
		case .err(let content):
			try container.encode(CodingKeys.err, forKey: .type)
			try container.encode(content, forKey: .value)
		}
	}
}
