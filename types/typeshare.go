// Code generated by typeshare 1.0.0. DO NOT EDIT.
package main

import "encoding/json"

type User struct {
	Id            uint32 `json:"id"`
	Name          string `json:"name"`
	Discriminator string `json:"discriminator"`
}
type UserResponseTypes string

const (
	UserResponseTypeVariantOk  UserResponseTypes = "Ok"
	UserResponseTypeVariantErr UserResponseTypes = "Err"
)

type UserResponse struct {
	Type  UserResponseTypes `json:"type"`
	value interface{}
}

func (u *UserResponse) UnmarshalJSON(data []byte) error {
	var enum struct {
		Tag     UserResponseTypes `json:"type"`
		Content json.RawMessage   `json:"value"`
	}
	if err := json.Unmarshal(data, &enum); err != nil {
		return err
	}

	u.Type = enum.Tag
	switch u.Type {
	case UserResponseTypeVariantOk:
		var res User
		u.value = &res
	case UserResponseTypeVariantErr:
		var res string
		u.value = &res

	}
	if err := json.Unmarshal(enum.Content, &u.value); err != nil {
		return err
	}

	return nil
}

func (u UserResponse) MarshalJSON() ([]byte, error) {
	var enum struct {
		Tag     UserResponseTypes `json:"type"`
		Content interface{}       `json:"value,omitempty"`
	}
	enum.Tag = u.Type
	enum.Content = u.value
	return json.Marshal(enum)
}

func (u UserResponse) Ok() *User {
	res, _ := u.value.(*User)
	return res
}
func (u UserResponse) Err() string {
	res, _ := u.value.(*string)
	return *res
}

func NewUserResponseTypeVariantOk(content *User) UserResponse {
	return UserResponse{
		Type:  UserResponseTypeVariantOk,
		value: content,
	}
}
func NewUserResponseTypeVariantErr(content string) UserResponse {
	return UserResponse{
		Type:  UserResponseTypeVariantErr,
		value: &content,
	}
}
